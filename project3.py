"""
Math 260
Final Project
Spring 2021

Partner 1: Ryan Iki (rni)
Partner 2: Sean Fiscus (sjf30)
Date: 04-19-21
"""

# Import math and p3tests.
import math
from p3tests import *

################################################################################

"""
Function called detectArbitrage(adjList, adjMat, tol=1e-15)

Function detects if there is any arbitrage by using Bellman-Ford to find if 
there is a negative cost cycle, and then traces the path backwards to find 
the cycle and returns a single list of vertex ranks corresponding to the 
negative cost cycle.

INPUTS
adjList:    the adjacency list representing the currencies graph
adjMat:     the adjacency matrix representing the exchange rates, 
            as generated by the rates2mat function
tol=1e-15:  tolerance value set to 1e-15 as a default (so that updates 
            smaller than the tolerance values are ignored) 

OUTPUT
ranks:      list of vertex ranks corresponding to the negative cost cycle, 
            must start and end at the same rank
            (list is empty if no negative cost cycle is detected)
"""
def detectArbitrage(adjList, adjMat, tol=1e-15):
    # Set initial dist (infinity) and prev (None) for each vertex
    for vertex in adjList:
        vertex.dist = math.inf
        vertex.prev = None

    # Select start vertex as first in adjList and set dist = 0
    adjList[0].dist = 0

    # Create variable numV to represent number of vertices in graph
    numV = len(adjList)

    # Iterate numV - 1 times
    for n in range(numV - 1):
        # Look at each vertex in graph
        for vertex in adjList:
            # Check each neighbor of vertex
            # Update predictions and previous vertex
            for nbr in vertex.neigh:
                # Create variable length to represent edge weight
                length = adjMat[vertex.rank][nbr.rank]
                # Only update if new value is better than tolerance value
                if nbr.dist > vertex.dist + length + tol:
                    nbr.dist = vertex.dist + length
                    nbr.prev = vertex

    # Create empty list to store vertices whose dist value
    # changes in final additional iteration
    changed = []
    
    # Iterate 1 more time to check for changes indicating arbitrage
    for vertex in adjList:
        for nbr in vertex.neigh:
            # Create variable length to represent edge weight
            length = adjMat[vertex.rank][nbr.rank]
            # Only update if new value is better than tolerance value
            if nbr.dist > vertex.dist + length + tol:
                nbr.dist = vertex.dist + length
                nbr.prev = vertex
                # Append vertex to changed list
                changed.append(nbr)


    # If changed list is empty, no negative cost cycle was detected
    # Return empty list for ranks
    if len(changed) == 0:
        return []

    # If changed list is not empty, there is a negative cost cycle
    # Initialize loop list to store negative cost cycle
    loop = []

    # Append first vertex from changed list to start to trace cycle
    loop.append(changed[0])

    # Set u to be the previous vertex to the vertex whose value changed
    # in the final iteration
    u = changed[0].prev

    # Trace backwards and add vertices to loop list to close the cycle
    # While previous vertex is not already in the loop, append that vertex
    # and look at the next previous vertex
    while u not in loop:
        loop.append(u)
        u = u.prev

    # While loop stopped executing, meaning u is already present in the loop
    # Append final vertex to loop list to close the cycle
    loop.append(u)

    # Remove vertices that are not part of cycle by finding index of starting
    # vertex (should be the same vertex as the last vertex in the loop) and
    # slicing the loop list based on this index
    end = loop[-1]
    startInd = loop.index(end)
    loop = loop[startInd:]

    # Create empty ranks list to store the rank of each vertex in cycle
    ranks = []

    # Iterate backwards through loop list and append the rank of each
    # vertex to create ranks list with cycle in the correct order
    for i in range(len(loop) - 1, -1, -1):
        ranks.append(loop[i].rank)

    # Return list ranks corresponding to the negative cost cycle
    return ranks

################################################################################

"""
Function called rates2mat(rates)

Modifies the 2D array rates that represents the exchange rates between 
currencies such that the returned adjacency matrix has the correctly weighted 
edges (edges should we weighted as -log(R), where R is the exchange rate
between currencies)

INPUT
rates:    a 2D array representing the exchange rates

OUTPUT
Adjacency matrix / 2D array representing the correctly weighted edges between 
vertices, such that edges are weighted as -log(R) where R is the exchange 
rate between the two currencies
"""
def rates2mat(rates):
    # Return adjacency matrix with correctly weighted edges
    # Edges are weighted as -log(R) where R is the exchange
    # rate between two currencies
    return [[-math.log(R) for R in row] for row in rates]

"""
Main function.
"""
if __name__ == "__main__":
    testRates()